package io.confluent.idesidecar.restapi.filters;

import io.confluent.idesidecar.restapi.application.SidecarAccessTokenBean;
import io.confluent.idesidecar.restapi.exceptions.Failure;
import io.confluent.idesidecar.restapi.resources.HandshakeResource;
import io.confluent.idesidecar.restapi.util.UuidFactory;
import io.quarkus.logging.Log;
import io.quarkus.vertx.web.RouteFilter;
import io.vertx.ext.web.RoutingContext;
import jakarta.inject.Inject;
import jakarta.inject.Provider;
import jakarta.ws.rs.core.HttpHeaders;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response.Status;
import java.util.List;
import java.util.StringTokenizer;
import org.eclipse.microprofile.config.inject.ConfigProperty;


/**
 * Request filter enforcing the presence of an access token in the Authorization header. The token
 * is generated by the {@link HandshakeResource} and stored in the shared
 * {@link SidecarAccessTokenBean}.
 * <p>Guards all paths for use by the sidecar other than the handshake route itself.</p>
 */
public class AccessTokenFilter {

  @Inject
  UuidFactory uuidFactory;

  @Inject
  SidecarAccessTokenBean accessTokenBean;

  // Config property to enable/disable the filter actually rejecting requests.
  // (On behalf of test suite, see test profile NoAccessFilterProfile)
  // (Must be a provider and very-late accessed here in a filter
  // to allow native compilations to still be able to override it
  // https://github.com/quarkusio/quarkus/issues/7607)
  @ConfigProperty(name = "ide-sidecar.access_token_filter.enabled", defaultValue = "true")
  Provider<Boolean> enabled;

  // Paths to exclude from being filtered.
  // All paths NOT intended to be used by the extension, plus the handshake route which is
  // used by the extension to establish the access token.
  @ConfigProperty(name = "ide-sidecar.access_token_filter.excluded_paths")
  List<String> excludedPaths;

  /**
   * Filter method enforcing the presence of an access token in the Authorization header.
   * <p>Rejects requests that do not have the proper token, unless the request is for an
   * unguarded route.</p>
   *
   * <p>>Filter level 100 is arbitrary in the absence of other filters. Higher priority filters
   * should be run first per
   * https://quarkus.io/guides/reactive-routes#intercepting-http-requests</p>
   *
   * @param rc The routing context.
   */
  @RouteFilter(100)
  public void enforceAccessToken(RoutingContext rc) {

    // Default to assuming to reject the request.
    boolean reject = true;

    String requestPath = rc.normalizedPath();

    if (excludedPaths.stream().anyMatch(requestPath::matches)) {
      // bypass the following checks ...
      reject = false;
    }

    // Parse authorization header, should be "Bearer <tokenvalue>". If the token value matches what
    // is known in SidecarAccessTokenBean, established by a prior hit to the handshake route, then
    // allow the request to go through.
    String authorizationHeader = rc.request().getHeader("Authorization");
    if (reject && authorizationHeader != null) {
      StringTokenizer tokenizer = new StringTokenizer(authorizationHeader);
      if (tokenizer.countTokens() == 2) {
        String tokenType = tokenizer.nextToken();
        String tokenValue = tokenizer.nextToken();

        String expectedToken = accessTokenBean.getToken();
        if (expectedToken == null) {
          if (enabled.get()) {
            Log.error(
                "Request for " + requestPath + " made before handshake route hit! Rejecting.");
          } else {
            Log.debug("Request for " + requestPath + " made without handshake.");
          }
        } else if ("Bearer".equalsIgnoreCase(tokenType) && tokenValue.equals(expectedToken)) {
          // Allow to pass through!
          reject = false;
        }
      }
    }

    if (reject && this.enabled.get()) {
      unauthorized(rc);
      // Do *not* call into next handler
    } else {
      // Let the request through. Was either for an unguarded route or had the proper token.
      rc.next();
    }
  }

  /**
   * Reject this request, including header describing my process id to assist vscode extension
   * killing me off since is an indication of being out of sync and needing to handshake again.
   */
  private void unauthorized(RoutingContext rc) {
    String message = "Missing or invalid access token.";
    var failure = new Failure(
        new Exception(message),
        Status.UNAUTHORIZED,
        "unauthorized",
        message,
        uuidFactory.getRandomUuid(),
        null
    );
    rc.response()
        .setStatusCode(Status.UNAUTHORIZED.getStatusCode())
        .putHeader(
            HandshakeResource.SIDECAR_PID_HEADER,
            String.valueOf(ProcessHandle.current().pid()))
        .putHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON)
        .send(failure.asJsonString());
  }
}

